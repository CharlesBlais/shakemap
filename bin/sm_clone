#!/usr/bin/env python

# stdlib imports
import sys
import os.path
import tempfile
from xml.etree.ElementTree import Element, ElementTree
from datetime import datetime
import shutil
import json
import argparse
from urllib import request

# third party imports
from libcomcat.search import get_event_by_id

# local imports
from shakemap.utils.config import get_config_paths
from shakelib.rupture.origin import write_event_file
from shakemap.utils.utils import get_network_name

TIMEFMT = '%Y-%m-%dT%H:%M:%SZ'
TIMEFMT2 = '%Y-%m-%dT%H:%M:%S.%fZ'


def get_parser():
    description = '''
    Download ShakeMap data from NEIC Comcat into a local data directory.

    Where eventid is a ComCat event ID.  For example, for this event:
    https://earthquake.usgs.gov/earthquakes/eventpage/us2000ar20
    The event ID is us2000ar20.

    If no source is specified, then the event ID used for the event directory, 
    eventid field in event.xml file, and names of data and fault files will
    be that of the *authoritative* origin.

    If a source (us, ci, nc, etc.) is specified, then that ID is used instead 
    of the authoritative ID.

    '''
    formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=formatter)
    parser.add_argument('eventid',
                        help='ID of the event to process')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Force overwrite of event data.')
    parser.add_argument('-s', '--source',
                        help='Specify the source network of desired shakemap.')
    return parser


def _get_event_dictionary(detail, source):
    edict = None

    if source is not None:
        # get basic event information from an origin contributed by input source
        try:
            origin = detail.getProducts('origin', source=source)[0]
            eventid = source + origin['eventsourcecode']
            edict = {'id': eventid,
                     'netid': source,
                     'network': get_network_name(source),
                     'lat': float(origin['latitude']),
                     'lon': float(origin['longitude']),
                     'depth': float(origin['depth']),
                     'mag': float(origin['magnitude']),
                     'time': origin['eventtime'],
                     'location': detail.location}
        except ValueError as ve:
            print('No %s origin for event %s.' % args.source)
    else:  # no source specified, use detail object
        edict = {'id': detail.id,
                 'netid': detail['net'],
                 'network': get_network_name(detail['net']),
                 'lat': detail.latitude,
                 'lon': detail.longitude,
                 'depth': detail.depth,
                 'mag': detail.magnitude,
                 'time': detail.time.strftime(TIMEFMT2),
                 'location': detail.location}
    return edict


def main(args):
    install_path, data_path = get_config_paths()
    if not os.path.isdir(data_path):
        print('%s is not a valid directory.' % data_path)
        sys.exit(1)

    # Get the DetailEvent product for this event ID
    # regardless of input, the output directory and files
    # will contain the *authoritative* event ID from ComCat,
    # unless source is specified.
    detail = get_event_by_id(args.eventid)
    # get input data
    edict = _get_event_dictionary(detail, args.source)
    eventid = edict['id']

    # check to see if the event directory exists
    event_dir = os.path.join(data_path, eventid, 'current')
    if not os.path.isdir(event_dir):
        os.makedirs(event_dir)
    else:
        if not args.force:
            print('Event directory %s already exists.  Use -f '
                  'option to overwrite.' % event_dir)
            sys.exit(1)
        shutil.rmtree(event_dir)
        os.makedirs(event_dir)

    # name the event.xml file
    event_xml_file = os.path.join(event_dir, 'event.xml')

    # write the event.xml file
    write_event_file(edict, event_xml_file)

    # if this event has a shakemap, then we have more to do
    if not detail.hasProduct('shakemap'):
        print('Event %s has no ShakeMap product.  Creating a basic ShakeMap.' %
              detail.id)
    else:
        if args.source:
            source = args.source
        else:
            source = 'preferred'
        try:
            shakemap = detail.getProducts('shakemap', source=source)[0]
        except AttributeError as ae:
            msg = 'No ShakeMap product from source % s exists.'
            print(msg)
            sys.exit(0)

        data_file = os.path.join(event_dir, '%s_dat.xml' % eventid)
        shakemap.getContent('stationlist.xml', filename=data_file)
        fault_files = shakemap.getContentsMatching('fault.txt')
        if len(fault_files):
            data_file = os.path.join(event_dir, fault_files[0])
            shakemap.getContent(fault_files[0], filename=data_file)
        print('Wrote %i files to %s.' %
              (len(os.listdir(event_dir)), event_dir))


if __name__ == '__main__':
    parser = get_parser()
    pargs = parser.parse_args()
    main(pargs)
