#!/usr/bin/env python

#stdlib imports
import logging.config
import os.path
import argparse
import sys
import traceback
import io
import socket
import pkgutil
import inspect
import importlib

#local imports
from shakemap.utils.config import(get_config_paths,
                                  get_configspec,
                                  get_shake_config,
                                  get_logging_config,
                                  get_logger)
import shakemap.coremods

#third party imports
from configobj import ConfigObj
from validate import Validator, ValidateError

def _get_command_classes():
    coremods = {
        name: importlib.import_module(name)
        for finder, name, ispkg
        in pkgutil.iter_modules(shakemap.coremods.__path__, 
                                shakemap.coremods.__name__ + ".")
    }
    
    classes = {}
    for name, module in coremods.items():
        for m in inspect.getmembers(module, inspect.isclass):
            if m[1].__module__ == name:
                core_class = getattr(module, m[0])
                if not hasattr(core_class,'command_name'):
                    continue
                cmd = core_class.command_name
                
                if not cmd:
                    continue
                classes[cmd] = core_class
    return classes
    
_classes_ = _get_command_classes()
    
def _format_error_info(exception,eventid):
    stringio = io.StringIO()
    ex_type, ex, tb = sys.exc_info()
    traceback.print_tb(tb,file=stringio)
    stack_trace = stringio.getvalue()
    stringio.close()
    hostname = socket.gethostname()
    error_msg = '\nHost: %s\nEvent ID: %s\nException: %s' % (hostname,eventid,stack_trace)
    return error_msg
                
def get_parser():
    description = '''
    Run all configured ShakeMap programs.

    The default behavior is to run silently, logging all output to configured log files
    and exceptions to email (if configured.)
    '''

    epilog = 'Available commands:\n'
    for key,core_class in _classes_.items():
        epilog += '  %s\n' % inspect.getdoc(core_class)
    
    parser = argparse.ArgumentParser(description=description,
                                     epilog=epilog,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('eventid',
                        help='The id of the event to process.')
    parser.add_argument('cmds',nargs='+',
                        help='The commands to run.')
    parser.add_argument('-d', '--debug', action='store_true',
                        help='Print all informational messages.')
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='Print only errors.')
    parser.add_argument('-l', '--log', action='store_true',
                        help='Log all output.')
    return parser

def main(args):
    install_path,data_path = get_config_paths()
    log_option = None
    if args.debug:
        log_option = 'debug'
    if args.quiet:
        log_option = 'quiet'
    if args.log:
        log_option = 'log'
        
    logger = get_logger(args.eventid,log_option=log_option)
    
    try:
        for cmd in args.cmds:
            if cmd not in _classes_:
                raise KeyError('Command %s not found in ShakeMap.' % cmd)
        
        for cmd in args.cmds:
            logger.info('Running command %s' % cmd)
            cmd_class = _classes_[cmd]
            cmd_obj = cmd_class(args.eventid)
            cmd_obj.execute()
            logger.info('Finished running command %s' % cmd)

    except Exception as e:
        error_msg = _format_error_info(e,args.eventid)
        logger.error(error_msg) #should get sent by email and logged
        
if __name__ == '__main__':
    parser = get_parser()
    pargs = parser.parse_args()
    main(pargs)
    sys.exit(0)
