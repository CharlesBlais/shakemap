#!/usr/bin/env python


import numpy as np
import openquake.hazardlib.geo as geo
import pyshake.shakelib.ecef as ecef
from pyshake.shakelib.vector import Vector
from pyshake.shakelib.distance import calcRuptureDistance
from pyshake.shakelib.distance import getDistance

"""
Implements the Rowshandel (2013) directivity model. 
"""

class rowshandel2013(object):
    """
    Class for Rowshandel2013 directvity model. 
    """
    #-----------------------------------------------------------------------------
    # C1 adn C2 are GMPE-specific coefficients. Also, these are for Model-I option. 
    #-----------------------------------------------------------------------------
    __c1 = {'as': np.array([0.375,0.561,0.833,0.873,1.019,1.387,1.551]), 
            'ba': np.array([0.257,0.699,0.824,0.834,0.986,1.378,1.588]),
            'cb': np.array([0.149,0.377,0.570,0.596,0.772,1.152,np.nan]), 
            'cy': np.array([0.079,0.321,0.629,0.693,0.898,1.258,1.369]),
            'id': np.array([0.325,0.803,1.544,1.576,1.823,2.089,2.250]),
            'T': np.array([1, 2, 3, 4, 5, 7.5, 10])}
    __c1['mean'] = (__c1['as'] + __c1['ba'] + __c1['cb'] + __c1['cy'] + __c1['id'])/5
    __c2 = {'as': np.array([0.028,-0.071,-0.130,-0.146,-0.178,-0.250,-0.268]), 
            'ba': np.array([0.024,-0.097,-0.133,-0.145,-0.182,-0.273,-0.319]),
            'cb': np.array([-0.007,-0.057,-0.095,-0.106,-0.144,-0.230,np.nan]), 
            'cy': np.array([-0.003,-0.404,-0.098,-0.115,-0.156,-0.224,-0.235]),
            'id': np.array([-0.019,-0.082,-0.228,-0.255,-0.312,-0.358,-0.369]),
            'T': np.array([1, 2, 3, 4, 5, 7.5, 10])}
    __c2['mean'] = (__c2['as'] + __c2['ba'] + __c2['cb'] + __c2['cy'] + __c2['id'])/5

    def __init__(self, flt, hyp, sites):
        """
        Constructor for rowshandel2013.
        :param fault:
            pyhsake fault object.
        :param hyp:
            hypocenter.
        :param sites:
            sites
        """
        self.flt = flt
        self.hyp = hyp
        self.sites = sites
        self.Wrup = computeWrup(flt, hyp)
        self.LD = computeLD(flt, hyp, sites, self.Wrup)
        # Dummy variables for now, in future get from rupture context
        T = 5
        M = 7.2
        # Should be possible to recycle Rrup calcs for DT
        self.DT = computeDT(flt, sites, T, simpleDT = False)
        self.WP = computeWP(T, M)

def computeFD():
    pass


def xi_prime(flt, hyp, sites, mtype = 1):
    slat = sites[1]
    slon = sites[0]
    xi_prime = np.zeros_like(slat)
    nm,nn = site_ecef_x.shape
    n_sub_faults = 0 # Normalize by total number of subfaults, can't know till loop is finished. 
    for k in range(len(flt.Quadrilaterals)):
        q = flt.Quadrilaterals[k]
        
        # Quad mesh (ECEF coords)
        mesh = fault.getQuadMesh(q, dx_km)
        
        # Rupture plane normal vector (ECEF coords)
        rpnv = getQuadNormal(q)
        
        # Unit slip vector (ECEF coords)
        slpv = getQuadSlip(q, rake)
        
        #-----------------------------------
        # i and j are indices over subfaults
        #-----------------------------------
        ni, nj = mesh['llx'].shape
        n_sub_faults = ni*nj + n_sub_faults
        xi_s_prime = 0
        xi_p_prime = 0 # sum over ni, nj
        for i in range(0, ni):
            for j in range(0, nj):
                #-----------------------------------
                # m and n are idices over sites
                #-----------------------------------
                for m in range(nm): ## m and n are loops over the sites
                    for n in range(nn):
                        cp = Vector(mesh['cpx'][i, j], mesh['cpy'][i, j], mesh['cpz'][i, j])
                        p = (cp - hypo_ecef).norm()
                        # project p1 onto the rupture plane 
                        # Note: this is a proposed simplification for multi-segment ruptures
                        #       Does not matter for planar ruptures (event multi-segment). 
                        #p = p1 - rpnv * rpnv.dot(p1)
                        site_ecef = Vector(site_ecef_x[m, n], site_ecef_y[m, n], site_ecef_z[m, n])
                        q = (site_ecef - cp).norm()
                        #q = (cp - site_ecef).norm()
                        pdotq = Vector.dot(p, q) 
                        sdotq = Vector.dot(slpv, q)
                        if mtype == 1: 
                            if pdotq > 0:
                                # Equation 3.2 in Spudich et al. (2013)
                                xi_p_prime = xi_p_prime + pdotq
                            if sdotq > 0:
                                # Equation 3.4 in Spudich et al. (2013)
                                xi_s_prime = xi_s_prime + sdotq         #### potentiailly take absolute value???
                        else:
                            # Equation 3.2 in Spudich et al. (2013)
                            xi_p_prime = xi_p_prime + pdotq
                            # Equation 3.4 in Spudich et al. (2013)
                            xi_s_prime = xi_s_prime + sdotq             #### potentiailly take absolute value???
                        xi_prime[m, n] = xi_prime[m, n] + a_weight*xi_s_prime + (1-a_weight)*xi_p_prime
    xi_prime = xi_prime / n_sub_faults
    return xi_prime

def computeLD(flt, hyp, sites, Wrup):
    # Convert hyp to epi
    epi_ll = Vector(hyp[0], hyp[1], 0)
    epi_ecef = Vector.fromPoint(geo.point.Point(epi_ll.x, epi_ll.y, 0))
        
    # Get the lines for the top edge of the fault
    qds = flt.Quadrilaterals
    nq = len(qds)
    top_lat = top_lon = np.array([[]])
    for j in range(0, nq):
        top_lat = np.append(top_lat, qds[j][0].latitude)
        top_lat = np.append(top_lat, qds[j][1].latitude)
        top_lon = np.append(top_lon, qds[j][0].longitude)
        top_lon = np.append(top_lon, qds[j][1].longitude)
        
    Lrup_max = 400
    slat = sites[1]
    slon = sites[0]
    LD = np.zeros_like(slat)
            
    ni, nj = LD.shape
    for i in range(ni): 
        for j in range(nj):
            #-----------------------
            # Compute Ls
            #-----------------------
            site_ll = Vector(slon[i, j], slat[i, j], 0)
            site2 = site_ll - epi_ll
            top_lat2 = top_lat - epi_ll.y
            top_lon2 = top_lon - epi_ll.x
                
            # Rotate to put epi-to-site line on x-axis
            alpha = np.arctan2(site2.y, site2.x)
            axis = [0, 0, 1]
            rmat = _rotation_matrix(axis, -alpha)
            llr = [None] * len(top_lat)
            for k in range(len(top_lat)):
                llr[k] = np.dot(rmat, [top_lon2[k], top_lat2[k], 0])
                site3 = np.dot(rmat, [site2.x, site2.y, 0])
                # Get the lognitude (lat=0) of Li
            Li_lon3 = np.min([np.max([a[0] for a in llr]), site3[0]])

            # Tansform back
            rmat = _rotation_matrix(axis, alpha)
            Li2 = np.dot(rmat, [Li_lon3, 0, 0])
            Li1 = Vector(Li2[0] + epi_ll.x, Li2[1] + epi_ll.y, 0)
            Li1_ecef = Vector.fromPoint(geo.point.Point(Li1.x, Li1.y,0))
                
            # Compute distance from epicenter
            Ls = (epi_ecef - Li1_ecef).mag()/1000
                
            #-----------------------------------
            # Compute LD
            #-----------------------------------
                
            Lrup = np.sqrt(Ls*Ls + Wrup*Wrup)
            LD[i, j] = np.log(Lrup)/np.log(Lrup_max)
    return LD


def computeWrup(flt, hyp):
    """
    Wrup is the portion (in km) of the width of the fault which 
    ruptures up-dip from the hypocenter to the top of the fault.
    * This is ambiguous for faults with varible top of rupture (not 
    allowed in NGA). For now, lets just compute this for the 
    quad where the hypocenter is located.
    * Alternative is to compute max Wrup for the different quads. 
    :param flt:
    fault object. 
    :param hyp:
    hypocenter tuple: lon, lat, depth (km). 
    """
    nquad = len(flt.Quadrilaterals)
    
    #-------------------------------------------
    # First find which quad the hypocenter is on
    #-------------------------------------------
    
    x,y,z = ecef.latlon2ecef(hyp[1],hyp[0],hyp[2])
    hyp_ecef = np.array([[x,y,z]])
    qdist = np.zeros_like([nquad])
    for i in range(0, nquad):
        P0,P1,P2,P3 = flt.Quadrilaterals[i]
        p0 = Vector.fromPoint(P0) # convert to ECEF
        p1 = Vector.fromPoint(P1)
        p2 = Vector.fromPoint(P2)
        p3 = Vector.fromPoint(P3)
        qdist[i] = calcRuptureDistance(p0,p1,p2,p3,hyp_ecef)
    ind = int(np.where(qdist == np.min(qdist))[0])  ## check that this doesn't break with more than one quad
    q = flt.Quadrilaterals[ind]
        
    #-------------------------------------------
    # Compute Wrup on that quad
    #-------------------------------------------
    
    pp0 = Vector.fromPoint(geo.point.Point(q[0].longitude, q[0].latitude, q[0].depth) )
    pp3 = Vector.fromPoint(geo.point.Point(q[3].longitude, q[3].latitude, q[3].depth) )
    hyp_ecef = Vector.fromPoint(geo.point.Point(hyp[0], hyp[1], hyp[2]))
    hp0 = pp0 - hyp_ecef
    p3p0n = (pp0 - pp3).norm()
    Wrup = Vector.dot(p3p0n, hp0)/1000
    return Wrup


def computeDT(flt, sites, T, simpleDT = False):
    slat = sites[1]
    slon = sites[0]
    site_z = np.zeros_like(slat)
    mesh = geo.mesh.Mesh(slon, slat, site_z)
    Rrup = np.reshape(getDistance('rrup', mesh, flt.Quadrilaterals), (-1,))
    nsite = len(Rrup)

    if simpleDT == True:   # eqn 3.10
        R1 = 35
        R2 = 70
        DT = np.ones(nsite)
        DT[(Rrup > R1) & (Rrup < R2)] = 2 - Rrup[(Rrup > R1) & (Rrup < R2)]/(20 + 10*np.log(T))
        DT[Rrup >= R2] = 0
    else:                  # eqn 3.9
        if T >= 1:
            R1 = 20 + 10 * np.log(T)
            R2 = 2*(20 + 10*np.log(T))
        else: 
            R1 = 20
            R2 = 40
        DT = np.ones(nsite)
        DT[(Rrup > R1) & (Rrup < R2)] = 2 - Rrup[(Rrup > R1) & (Rrup < R2)]/35
        DT[Rrup >= R2] = 0
        DT = np.reshape(DT, slat.shape)
    return DT

def computeWP(T, M):
    # Narrow-band multiplier, WP
    sig = 0.6
    Tp = np.exp(1.27*M - 7.28)
    WP = np.exp(-(np.log10(T/Tp)*np.log10(T/Tp))/(2*sig*sig))
    return WP


def _rotation_matrix(axis, theta):
    """
    Return the rotation matrix associated with counterclockwise rotation about
    the given axis by theta radians.
    Source: Response by 'unutbu' in this thread: 
    http://stackoverflow.com/questions/6802577/python-rotation-of-3d-vector
    """
    axis = np.asarray(axis)
    theta = np.asarray(theta)
    axis = axis/np.sqrt(np.dot(axis, axis))
    a = np.cos(theta/2)
    b, c, d = -axis*np.sin(theta/2)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return np.array([[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
                     [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
                     [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]])
